using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

using static FuzzyPlusCSharp.StringMatchingAlgorithms.Sift4;

namespace FuzzyPlusCSharp.StringMatchingAlgorithms
{
#pragma warning disable CRR0047 // Disabling this warning because we want to keep this class here to simplify the code.
    public class ISimHash : FuzzyPlusCSharp.StringMatchingAlgorithms.IDistance
    {
        public double Percentage(string source1, string source2, bool isCaseSensitive = true)
        {
            double d = Distance(source1, source2, isCaseSensitive);
            return 1.0f - (d / Math.Max(source1.Length, source2.Length));
        }
        public double Distance(string source1, string source2, bool isCaseSensitive = true)
        {
            Fuzzy.FixIfIsCaseSensitive(ref source1, ref source2, isCaseSensitive);
            return (double)SimHash.HammingDistance(SimHash.CalculateHash(source1), SimHash.CalculateHash(source2));
        }
    }
    public class ISimHash2 : FuzzyPlusCSharp.StringMatchingAlgorithms.IDistance
    {
        private int HashLen;
        public double Percentage(string source1, string source2, bool isCaseSensitive = true)
        {
            double d = Distance(source1, source2, isCaseSensitive);
            return 1.0f - (d / HashLen);
        }
        public double Distance(string source1, string source2, bool isCaseSensitive = true)
        {
            Fuzzy.FixIfIsCaseSensitive(ref source1, ref source2, isCaseSensitive);
            source1 = SimHash.SimHashAlgorithm(source1);
            HashLen = source1.Length;
            return (double)SimHash.HammingDistance(source1, SimHash.SimHashAlgorithm(source2));
        }
    }
    public class SimHash
    {
        public static int HammingDistance(string hash1, string hash2)
        {
            //Hamming distance in a simpler, more understanding way
            return hash1.Where((t, i) => t != hash2[i]).Count();

            #region Hamming distance in a simpler, more understanding way

            //var result = 0;
            //for (int i = 0; i < hash1.Length; i++)
            //{
            //    if (hash1[i] != hash2[i])
            //    {
            //        result++;
            //    }
            //}
            //return result;

            #endregion

        }
        public static string SimHashAlgorithm(string text)
        {
            MD5 md5 = MD5.Create();

            //the hash generated by md5.ComputeHash() is always 128 bits
            var sh = new int[128];
            var words = text.Split();
            foreach (var word in words)
            {
                var wordToBytes = Encoding.ASCII.GetBytes(word);
                var hash = md5.ComputeHash(wordToBytes);
                for (int i = 0; i < hash.Length; i++)
                {
                    //    128  ,    64   ,    32   ,    16   ,     8   ,     4   ,    2    ,    1
                    // 10000000, 01000000, 00100000, 00010000, 00001000, 00000100, 00000010, 00000001
                    //j in the following for loop serves as a mask to check if hash[index] is 1 or 0
                    var br = 0;
                    for (int j = 128; j > 0; j /= 2)
                    {
                        var index = (i * 8) + br;
                        br++;

                        if ((hash[i] & j) != 0)
                        {
                            sh[index] += 1;
                        }
                        else
                        {
                            sh[index] -= 1;
                        }
                    }
                }
            }
            for (int k = 0; k < sh.Length; k++)
                sh[k] = sh[k] >= 0 ? 1 : 0;
            return string.Join("", sh);

            #region Check to see if SimHash works with hex example

            //var binaryString = string.Join("", sh);
            //StringBuilder result = new StringBuilder();
            //for (int i = 0; i < binaryString.Length; i += 8)
            //{
            //    string eightBits = binaryString.Substring(i, 8);
            //    result.AppendFormat("{0:x2}", Convert.ToByte(eightBits, 2));
            //}

            #endregion

        }
        /// <summary>
        /// Fast Hash
        /// From http://stackoverflow.com/a/9545731
        /// </summary>
        /// <param name="read"></param>
        /// <returns></returns>
        public static ulong CalculateHash(string read)
        {
            var hashedValue = 3074457345618258791ul;
            foreach (var t in read)
            {
                hashedValue += t;
                hashedValue *= 3074457345618258799ul;
            }
            return hashedValue;
        }

        /// <summary>
        /// Fast HammingDistance
        /// From 
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        public static ulong HammingDistance(ulong left, ulong right)
        {
            var bb = left ^ right;
            const ulong c55 = 0x5555555555555555ul;
            const ulong c33 = 0x3333333333333333ul;
            const ulong c0F = 0x0f0f0f0f0f0f0f0ful;
            const ulong c01 = 0x0101010101010101ul;

            bb -= (bb >> 1) & c55;
            bb = (bb & c33) + ((bb >> 2) & c33);
            bb = (bb + (bb >> 4)) & c0F;
            return (bb * c01) >> 56;
        }
    }
}
